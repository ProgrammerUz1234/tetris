const ROWS = 20;const COLS = 10;const BLOCKS = {    I: [[1, 1, 1, 1]],    O: [        [1, 1],        [1, 1]    ],    T: [        [0, 1, 0],        [1, 1, 1]    ],    S: [        [0, 1, 1],        [1, 1, 0]    ],    Z: [        [1, 1, 0],        [0, 1, 1]    ],    L: [        [1, 0, 0],        [1, 1, 1]    ],    J: [        [0, 0, 1],        [1, 1, 1]    ]};let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));let currentBlock = getRandomBlock();let position = { row: 0, col: Math.floor(COLS / 2) - 1 };let gameInterval;let gameOver = false;// Initialize game board in HTMLconst boardElement = document.getElementById('tetris-board');function drawBoard() {    boardElement.innerHTML = '';    board.forEach(row => {        row.forEach(cell => {            const cellDiv = document.createElement('div');            cellDiv.classList.add('cell');            if (cell) cellDiv.classList.add('filled');            boardElement.appendChild(cellDiv);        });    });}// Draw active blockfunction drawBlock() {    const { row, col } = position;    currentBlock.forEach((blockRow, r) => {        blockRow.forEach((cell, c) => {            if (cell && board[row + r] && board[row + r][col + c] === 0) {                boardElement.children[(row + r) * COLS + col + c].classList.add('active');            }        });    });}// Get random blockfunction getRandomBlock() {    const blockKeys = Object.keys(BLOCKS);    const randomKey = blockKeys[Math.floor(Math.random() * blockKeys.length)];    return BLOCKS[randomKey];}// Move blockfunction moveBlock(direction) {    const { row, col } = position;    let newCol = col + (direction === 'left' ? -1 : 1);    if (!collides(row, newCol)) position.col = newCol;    update();}// Drop blockfunction dropBlock() {    const { row, col } = position;    if (!collides(row + 1, col)) {        position.row++;    } else {        placeBlock();        clearRows();        resetBlock();    }    update();}// Check collisionfunction collides(newRow, newCol) {    return currentBlock.some((blockRow, r) =>        blockRow.some((cell, c) =>            cell && (board[newRow + r] && board[newRow + r][newCol + c]) !== 0        )    );}// Place block on the boardfunction placeBlock() {    const { row, col } = position;    currentBlock.forEach((blockRow, r) => {        blockRow.forEach((cell, c) => {            if (cell) board[row + r][col + c] = 1;        });    });}// Clear full rowsfunction clearRows() {    board = board.filter(row => row.some(cell => !cell));    while (board.length < ROWS) board.unshift(Array(COLS).fill(0));}// Reset block position and get new blockfunction resetBlock() {    position = { row: 0, col: Math.floor(COLS / 2) - 1 };    currentBlock = getRandomBlock();    if (collides(position.row, position.col)) {        gameOver = true;        clearInterval(gameInterval);        document.body.innerHTML += '<div class="game-over">Game Over</div>';    }}// Update game statefunction update() {    drawBoard();    drawBlock();}// Start game loopfunction startGame() {    gameInterval = setInterval(dropBlock, 500);}document.addEventListener('keydown', (e) => {    if (gameOver) return;    if (e.key === 'ArrowLeft') moveBlock('left');    if (e.key === 'ArrowRight') moveBlock('right');    if (e.key === 'ArrowDown') dropBlock();});// Start game on loadstartGame();